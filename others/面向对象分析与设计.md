# 面向对象分析与设计

## 第一章 面向对象概述

### 1.1 序言

*当下热门领域：工业互联网、大数据、云计算、网络安全*

**软件危机**

**课程目标**
* 软件工程师
* 卓越软件人才

>卓越软件人才
>系统分析和设计理论基础，掌握大系统需求分析、建模与仿真技术
>应用系统设计能力，能够从事新兴产业软件的研发
>国际前沿技术学习能力和交流能力
>项目管理能力及自主业务提升能力

**课程期望**
帮助掌握面向对象的思维方式，并在系统分析、软件设计中加亿应用

### 1.2 课程定义
* 一种思维方式
* 一种思考如何用面向对象方法去思考的课程

**与课程相关的其他课程**
UML、Design Pattern、Required System、C++/C#/java，etc

>对创建对象系统来说，了解面向对象语言，UML工具是必要的；但是，了解“对象思想”才是最重要的！

### 1.3 面向对象思想的起源
>艾伦-凯
>Smalltalk语言之父
>创造性地提出面向对象编程思想
>体术Dynabook的概念
>2003年获得图灵奖
>言论：他提倡应该关注消息机制和模块间的松耦合和交互，而不是模块内部的对象组成；做出非凡和可成长的系统的重中之重是设计好模块之间如何通讯，而不是模块应具有什么样的内容属性和行为方法

### 1.4 面向对象的基本概念
* 类 Class
* 对象 Object

>注意：概念之间的互用：
>属性Attribute == 数据Data == 状态state == 信息information
>操作operation == 方法Method == 行为behaviour == 职责responsibility
>对象object == 实例instance

* 类--定义了对象群体的逻辑结构，包括属性和操作；系统运行时，类作为产生对象的模板，在物理层面是不存在的
* 对象--系统运行时必须为每一个需要的对象分配内存、保存数据；对象存在于物理层面，每个对象都有自己的数据空间（内存）；所有的对象共享同一块代码空间
* 消息--对象之间的一种交流手段
**所有相关对象之间相互协作完成软件功能**

### 1.5 面向对象的思考方式
>对于想要成为问题解决者的人来说，入门的关键时”把单一思维模式切换成多重思维模式

*软件系统时由多个对象组成，对象间通过消息相互交流，共同协作，以完成整个系统的功能*

* 面向对象的思考方式：在对世界/系统进行观察/建模的时候，把它们看成时一系列相互交流、互为影响的对象集（a set of objects）

**面向对象适合解决不确定的事件、创新性的事件；而面向过程适合处理已知的事实、重要的条件都已知的场景**

* 面向对象解决方法通过信道传递对象（数据+对数据的处理方法）

>课程主要概念
>面向对象分析 OO analysis
>面向对象设计 OO design
>设计模式 design patterns
>统一建模语言 UML
>面向对象编程 OO programming
>**最重要的是：以面向对象的思维方式去思考要解决的问题**

### 1.6 面向对象的核心特征（一）
* 封装：隐藏了对象的实现细节；内部的状态不为其他对象所访问；对象的数据只能通过接口进行访问
* 继承
* 多态：当一个类从另一个类继承而来，多态使得子类可以代替父类；消息发送方不需要知道消息接收方属于哪个类；同一类族的接收者可以按自己的方式处理消息

**使用指向父类的指针或引用，能够调用子类的对象--这是多态的核心思想，是设计模式的基础**

### 1.7 面向对象的核心特征（二）
* 聚合/组合（整体/部分）：聚合关系的一种变种，称为组合；组合强调整体控制着部分的生命；有时候，聚合与组合的关系不是很明确
* 接口/实现：接口指描述一个类的用户如何与这个类交互；实现指完成接口所定义的功能，如类、构件等完成的任务
* 抽象：一种思维方式、一种思维能力；抽象表示一个对象与其他所有对象相区别的基本特征，就是过滤掉对象的一部分特性和操作，直到只剩下你所需要的属性和操作

**抽象是面向对象领域发现类的主要方法**

## 第二章 建模工具UML

### 2.1 UML序言
* 建模：分析、设计，即发现正确的问题、发现正确的解决方案；把不太理解的东西和一些已经较为理解、且十分类似的东西作比较，可以对这些不太理解的东西产生更深刻的理解；重要的研发成果常常产自类比
* 模型：建模产生的结果；模型是对现实的简化、对事物的一种抽象，可以帮助人们更好的了解事物的本质，抓住问题的要害；在模型中，人们总是剔除那些与问题无关的、非本质的东西，从而使模型与真实的实体相比更加简单、易于把握

>建模的四项基本原理
>选择要创建什么模型
>每一种模型可以在不同的精度级别上表示
>最好的模型是与现实相关联的
>单个模型是不充分的，对每一个重要的系统最好用一组几乎独立的模型去处理

* UML：统一建模语言，类似于一个工具包，是软件分析师、设计师的工具包，用于创建各种模型

* UML由事物、关系、图组成；事物由结构事物、行为事物、分组事物和注释事物组成；关系有依赖、关联、泛化和实现；较为重要的图有类图、顺序图、用例图、活动图和状态图
* UML公有机制：详述、修饰、通用划分、扩展机制（构造型、标记值、约束）
* UML常用的符号

### 2.2 用例模型
**用例模型包含：系统边界、参与者、用例、用例图、用例描述**
**用例模型是系统分析的结果、是系统设计的输入**

* 参与者（Actor）：位于系统之外并和系统进行交互的一类事物（人、物、其他软件子系统等），通过它，可以对软件系统与外界发生的交互进行分析和描述，可以了解客户希望软件系统提供哪些功能

* 根据下面的问题来寻找系统的参与者：
	1.谁使用系统
	2.谁安装系统、维护系统
	3.谁启动系统、关闭系统
	4.谁从系统中获取信息，谁提供信息给系统
	5.在系统交互中，谁扮演了什么角色
	6.系统会与哪些其他系统相关联
	7.内/外部定时器
	**对每一类参与者要有简短描述**

* 用例（Usecase）：系统为响应参与者引发的一个事件而执行的一系列的处理/动作，而这些处理应该为参与者产生一种有价值的结果；这些动作不但要包含正常情况下的各种动作序列，还应该包含对非正常情况的软件系统的动作序列的描述

* 可以根据下面的一些问题来识别用例
	1.参与者希望系统提供什么功能
	2.系统是否存储和检索信息
	3.当系统改变状态时，是否通知参与者
	4.是否存在影响系统的外部事件，是哪个参与者通知系统这些外部事件
	5.哪个参与者触发了活动
	**每个用例都有一个名称：短小精悍的“动名词”**
	
* 用例图中的关系
	1.参与者与用例之间：关联关系，用实线表示
	2.参与者/参与者之间的关系：泛化关系，实线+空心箭头
	3.用例之间的关系：泛化关系、包含关系、扩展关系

* 用例描述：仅有用例图还不够，还需要详尽的文字描述

>用例描述（规范示例）
>Summary
>Actor List
>Pre-condition
>Description
>Post-condition
>Exception

*补：主事件流 + 异常事件或可选事件流（主事件流的每一步都可能出现异常）*

### 2.3 活动图
* 概念：活动图描述了在一个过程中，顺序的/并行的活动及其之间的关系
* 应用：商业过程、工作流（业务过程）、复杂算法的建模
* 活动图是顶点和弧的集合。包括活动节点、动作、流、对象值、注释和约束等
* 活动图与用例模型互为补充，主要用于需求分析阶段
* 活动图中基本要素包括：活动（动作）、转移、分支、分叉和汇合、泳道、对象流等

>活动图基本建模元素
>活动图的开始、结束、对象
>活动节点：一个活动是一个过程中进行的非原子的执行单元；活动的执行最终延伸为一些独立动作（Action）的执行
>分支：一个分支可以有一个进入点和多个离去流；在每个离去流上必须设置一个监护条件；两个控制路径可以重新合并，无需监护条件
>分岔和汇合：分岔表示把一个单独的控制流分成两个或以上并发的控制流；汇合表示两个或以上控制流同步发生，一个汇合可以有两个或以上进入转移和一个输出转移；在UML中，用同步棒（水平或垂直的粗线条）来说明并行控制流的分岔和汇合
>泳道：将一个活动图中的活动分组，每一组表示一个特定的类别、人或部门，他们负责完成组内的活动；泳道是包的一种

### 2.4 类图
* 把类相关的元素画在一起，即为类图
* 类之间的关系
	依赖（······>）
	关联（------）：多重性、角色、名称方向、聚合（空心菱形表示）/组合（实心菱形表示）、关联类
	继承/泛化（-----I>）
	实现（······I>）
* 类的图形表示：四部分（名称、属性、操作、职责）
* 当一个类的名称有冒号或者下划线时，即表示该为类的对象
* 类元素命名：
	类的命名：每个单词的首字母大写
	操作和属性命名：除第一个单词外的每个单词首字母大写
* 最重要的是如何用面向对象思维方式去思考，去发现类、定义类、定义类之间的关系、定义每个类应该承担的职责

### 2.5 顺序图
* 相关概念
	交互：对象之间为实现某一功能而必须实施的协作过程、动态行为
	消息：对象间的协作与交流表现为一个对象以某种方式启动另一个对象的活动
	顺序图的建模元素：对象或角色（参与者）、生命期、控制焦点、消息==方法调用、消息序号（可选）
	交互图：交互的过程表现出来，即为交互图（顺序图、通信图都是交互图）
* 交互的基本概念--消息
	同步消息（A给B发消息，B必须回复A消息，才能继续运行）
	异步消息（A发消息到队列中，然后去执行其他事情；B查看队列，发现消息并回复；A后续查看队列，看到消息）
* 顺序图中的结构化控制：
	可选执行（标签：opt）
	条件执行（标签：alt）
	并行执行（标签：par）
	循环（迭代）执行（标签：loop）

### 2.6 通信图
* 通信图本质上与顺序图是一样的，可以互换，只是二者的建模角度不同（顺序图强调随着时间的推移，各对象是如何交互的；通信图强调对象之间的结构关系）
* 通信图的构成：对象、链接、在此链接上传递的消息

### 2.7 状态图
* 状态是对象的生命周期中的一个条件或状况；在此期间，对象可以响应事件、执行某活动等
* 状态机是一种行为，说明对象在它的生命周期中，响应事件所经历的状态序列以及它们对每个事件的响应
* 状态机可以用状态图来可视化；状态图显示了一个状态机，它强调从状态到状态的控制流
* 状态的组成：名称（每个单词首字母大写）、进入/退出动作、内部迁移、子状态、延迟事件
* 事件是对一个在时间和空间上占有一定位置的有意义的事情的描述（在状态机的语境中，一个事件是一个激励的发生，它能够触发一个状态迁移）
* UML对4种事件进行建模：
	参量变化（布尔表达式值变化、定时器、溢出是内部事件）
	信号（异步）
	调用（同步）
	时间事件（时间事件表示一段时间的推移，关键字为after和at；变化事件表示状态的一个变化或某些条件得到满足的事件）
* 迁移：在状态A发生事件并满足一定条件后，转到状态B
	一个迁移由5部分组成：源状态、事件触发器、触发条件、效应（迁移动作--可执行的动作）、目标状态
	特殊的迁移：自身迁移、内部迁移（状态A内部行为）
* 状态图的建模元素：
	状态：一般状态（圆角矩形）、初始状态（实心圆）、结束状态（“牛眼”）
	事件：触发事件名[触发条件]/迁移动作
	迁移（叉形箭头实线）
* 状态图的建模步骤：选择对象及视点 --> 定义对象在生命期内可能存在的状态 --> 在每种状态下可以接受的事件及将要转去的新的状态
* 状态图建模注意事项：不允许孤立的状态存在；不允许只进不出的状态迁移（“黑洞”）；不允许只出不进的状态迁移（“奇迹”）；不允许没有事件发生的迁移（或者“迁移”没有指明具体事件）
* 比较状态图与交互图、活动图
	交互：对共同工作的对象群体的行为建模；动态行为
	状态机：对单个对象的行为建模；动态行为
	活动图：强调从活动到活动的控制流，多个业务角色；状态图则强调对象潜在的状态和这些状态之间的迁移

## 第三章 面向对象分析（一）

### 3.1 面向对象分析与设计概览

* 高质量的软件系统具有架构性的内聚、可重用性、可维护性、可扩展性、灵活性
* 系统设计中的关键问题：应该如何为对象类分配职责？对象之间应该如何协作？什么样的类应该做什么样的事情？某些针对设计问题的、经过反复验证的解决方案，可以（或者已经）被表示成为最佳实践的原则、启示或者模式，如何用、如何自创？
* 面向对象的过程：分析、设计、实现、部署
* 分析与设计的关系：做正确的事情（分析），正确地做事情（设计）
* OOAD基本过程：定义用例、定义领域模型、定义交互图、定义设计类图

### 3.2 面向对象分析方法（一） 名词法
* 在软件工程，分析是一种过程，把用户需求转变为系统需求；系统规格说明，也称为逻辑结构，是开发人员眼中的系统
* 大的、复杂系统的开发，有两种主要的分析方法：面向功能分析和面向对象分析
* 面向对象分析的主要步骤：识别对象、组织对象、定义对象之间的关系、定义对象的操作（设计阶段完成）、定义对象内部细节
* 面向对象分析的方法：名词法（概念模型）、分析模型、CRC法（类/职责/协作）
* 一个好的分析师掌握多种技术，知道如何混合使用各种技术，目标只有一个：发现对象、定义对象之间的关系
* 名词法定义概念：重用或修改已有的模型；借助行业、公司内部法的“概念类列表”；在需求描述中查寻名词（短语）

### 3.3 面向对象分析方法（一） 名词法案例

### 3.4 面向对象分析方法（二） 分析模型法
* 分析模型法：用于描述系统规格说明；是一个健壮、稳定的模型，必须与实现环境（C++、Java）无关；实现环境的任何变化，不会影响到系统的逻辑结构；分析模型能够关注到系统的信息、行为、展示（输入/输出）等特性
* 分析模型的表示符号：实体、边界/接口、控制

### 3.5 面向对象设计（初步）
* 一般原则：一个系统由相互之间存在消息关系的对象组成；每个对象“人尽其责”
* 职责驱动的设计（RDD）：设计时考虑对象做什么，或者知道什么；一个对象对其他对象承担的义务或合约；职责是一个对象的行为，而其他对象依赖这种行为
* 认知职责（对象的私有属性、相关对象、关于对象的计算等能力）、行为职责（自己可以做某事、初始化其他对象的行为、控制和协调其他对象的行为）

## 第四章 面向对象分析（二）

### 4.1 标识概念类和对象的注意点
* 原则：类，表示一组具有相同行为、属性的对象；在表示对象群体的时候，一般用单数；根据类，可以创建所需要数量的对象个体
* 类名的选择很重要！！！
* 可能的抉择：一个名词，是作为概念类合适，还是作为某个类的属性更合适？
* 一般原则：对问题了解得越细越彻底，越有把握做出决定
* 在适当的细节层面定义概念类（发现一个类非常复杂时，要考虑拆分成多个小一点的类，但是又不能太多的类，主要取决于我们处理的实际问题）
* 在标识概念类的过程中，同时要考虑每个类的职责分配，但是不需要在领域模型中明示
* 总的原则：即将要开发的系统，每项任务（每个职责）都需要有一个或多个类去处理；表示成类的操作（一般是动词）；在分析、设计的早期，不必要定义每个类的每个操作；一开始，表示成较为粗犷的职责描述

### 4.2 CRC方法标识概念类
* CRC：类--职责--协作，也称为CRC索引卡片
* CRC特点：非正式的，不是很细节；CRC的目标不是提供完整的设计，其产生的结果需要进一步精化
* CRC的输入信息：用例模型
	用例图、边界、用例描述，清楚地描述了系统需求，作为CRC概念类分析的起点；用例描述的正常事件流、异常事件流，可以作为CRC的“角色扮演”的脚本

### 4.3 CRC方法建模的一些规则
* CRC编写人员组成：领域专家 + 系统分析师 + 软件设计师 + 团队引导者 + 用户（非必要）
* 头脑风暴：收集各种各样的想法，比较这些想法并进行合成
* 在进行头脑风暴之前，收集概念类可能的来源（每个参与者要完成一些调查、分析任务）
* CRC寻找结束后，“角色扮演”验证概念类

### 4.4 CRC方法建模的案例：ATM取款机软件
* 步骤：需求描述 --> 建议的概念类 --> 标识核心概念类（关键的、无关的、待定的） --> 明确系统范围 --> 去掉不必要的核心类（合并同义词） --> 新的核心类 --> 无关的类 --> 为核心类分配职责 --> 分配协作

* 符合以下两点的类，一般是属性：
	它不做具体的事情，它不能改变状态
* 在为核心类分配职责时，主要考虑做什么而不是具体怎么做

## 第五章 领域模型

### 5.1 领域模型定义
* 领域模型：一种概念模型，问题领域的概念的表示
* 如何表示领域模型？简单地说，“没有定义操作的类图”
* 低表示差异（领域模型VS设计模型）
* 如何创建领域模型？找概念类、添加关系、添加属性
* 理解概念类的三个层面：符号（表象）、内涵、外延
* 领域模型VS数据模型

### 5.2 领域模型建模指导
* 是否利用工具建模：创建领域模型的目的是快速地理解关键的概念；完美不是目标；是否利用工具，酌情
* 构建领域模型，类似地图制作：使用现有的名词；剔除无关的、或者超出范围的一些特征；不需要增加没必要的概念
* 属性和类的选择：如果认为某概念类不是现实世界中的数字或文本，那么其可能是概念类而不是属性；如果有很多元素构成、有一些操作作为或有数量单位，那么可能是一个类
* 对一些描述性质的概念建模，可以单独作为概念类
* 定义成“描述”类的原则：如果描述内容独立于对应的事物，如产品、产品描述；如果剔除对象的同时剔除了描述，而该描述还需要继续维护；为了减少重复或更清晰

### 5.3 领域模型案例

### 5.4 系统顺序图
* 把待建的系统看成一个黑盒子，研究参与者与系统边界的交互
* 系统事件、系统操作
* 系统顺序图VS顺序图
* 系统顺序图VS用例（互为补充）

### 其他的需求信息
* 其他需求
	初期阶段：部分的词汇表、数据字典、前景描述
	精化阶段：业务规则、接近完整了（较少新的需求）
	构建阶段：微小的修改
* 补充规则说明 -- FURPS+：功能性、可使用性、可靠性、性能、可支持性、实现约束、购买还是开发、接口、法律问题
* 前景包括问题陈述、涉众及其关注点、重要的角色及其目标、产品的概况
